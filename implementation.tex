\begin{table*}[t]

\input{./figures/surveytable.tex}

\caption{\textbf{Detailed mocking survey results.} All values are percentages
of the 91 respondents. Levels of knowledge we considered to be unreasonable
are marked in bold in the accuracy row.}

\label{table-surveyresults}

\end{table*}

\section{Implementation}
\label{sec-implementation}

We implemented a \PocketMocker{} prototype on Android 4.2.2 ``Jelly Bean'',
Android being the only open-source smartphone platform permitting the
platform modifications \PocketMocker{} requires. Our current prototype
supports recording and replaying context traces and mocking location,
available networks and signal strengths, and sensors including the GPS,
accelerometer and gyroscopes. We have deployed our prototype on the Samsung
Galaxy Nexus smartphone~\cite{galaxynexus} which was used for the experiments
in Section~\ref{sec-evaluation}.

% 02 Apr 2014 : GWA : NR TODO : Sanity check: can unprivileged apps really
% read from sysfs? no?

We considered implementing \PocketMocker{} support in two ways: either by
modifying Android platform services, or by making changes to the underlying
Linux kernel. Most Android platform services provide thin wrappers around
low-level Linux interfaces in order to provide and protect Android interfaces
to modifying core smartphone features. For example, the \texttt{WifiManager}
Android interface for switching access points translates requests from apps
with permission to use the interface into the appropriate manipulations of
the wireless connection state using tools that unprivileged Android apps lack
the permissions to use. Because Android apps typically use Android's service
interfaces to collect information about the device, such as determining the
access point that the smartphone is currently associated with, it is possible
to implement successful mocking with these services and fool many apps.

Unfortunately, the underlying Linux interfaces on Android leak a great deal
of information about the state of the system that apps could use to pierce
the mocking context. For example, reading \texttt{/prot/net/arp} allows an
unprivileged app to determine the access point the smartphone is associated
with in the same way as a call to the \texttt{WifiManager} Android service.
So implementing mocking \textit{only} within the Android platform is not
sufficient to fully secure the mocking context, since apps may be able to
bypass services participating in the mocked process. The most secure way to
implement mocking would be to make changes to the Linux kernel itself to
ensure that all information provided by the system would be consistent.

At present, however, our current \PocketMocker{} prototype is implemented as
a set of changes to Android. This is for two reasons. First, \PocketMocker{}
is currently designed to fool unsuspecting apps, and we have left as future
work the task of exploring ways apps could attack the mocking context and
effective \PocketMocker{} countermeasures, including moving mocking support
into Linux itself. Our evaluation demonstrates that platform changes are
sufficient to mock many different apps. Second, modifying Android reduced the
developer effort needed to produce a working prototype allowing us to test
and better understand the system.

% 02 Apr 2014 : GWA : NR TODO : Finish with specific details.

The architecture of \PocketMocker{} consists of two phases, one sitting in the
app layer and the other in the Android platform. We handle user 
interaction, data logging, and data replaying in the app layer.
In the platform, we have made modifications allowing \PocketMocker{} to notify 
user-installed apps of location and sensory updates through their respective 
callbacks.

Users interact with the app itself, which allows for initiating the
recording and replaying processes, and managing objectives. A user must
create an objective before recording data; otherwise the system cannot
associate a trace with a particular goal. During a recording session, we
aggressively log device events to the application-layer database. 
\PocketMocker{} registers a \texttt{LocationListener} with the
\texttt{LocationManager} that records \texttt{onLocationChanged} at a rate of
1 \texttt{Location} per second---our listener also logs
\texttt{onProviderDisabled}, \texttt{onProviderEnabled}, and
\texttt{onStatusChanged} events. For each \texttt{onLocationChanged}, we also
scan for nearby wireless acces points through the \texttt{WifiManager} and
collect the \texttt{CellLocation} provided by the \texttt{TelephonyManager}.
We also register a \texttt{SensorEventListener} with the
\texttt{SensorManager} to collect sensor events---such as
\texttt{onAccuracyChanged} and \texttt{onSensorChanged}---at a defined rate
of \texttt{SENSOR\_DELAY\_GAME}, which is somewhere between 37--39
milliseconds. For all logged data, we serialize it into the database such
that it can be reconstructed as a Java object later. In the background is the 
replay service, an Android \texttt{Service}, that manages platform clients and 
their respective publish-subscribe channels for replaying sensory data. When 
replaying data to the platform, we update relative data, such as timestamps, 
to reflect current device time.

\newpage
We have instrumented changes to the Android platform that allows each of the
above managers to communicate with the \PocketMocker{} replay service. The
managers now implement \texttt{Messenger} handlers to receive
\texttt{Messages} from external channels. On construction of a manager, it
sends a \texttt{Message} to the replay service, notifying the service of its
existence and establishing a bidirectional channel of communication. On
receipt of a \texttt{Message} containing mocked data from the replay service,
we can create actual \texttt{Location}, \texttt{SensorEvent}, and other
objects from the serialized data packaged in the incoming \texttt{Message}.
With these Java objects, we can now call the callback functions on listeners
for the particular manager---for example, we can pass a newly constructed
\texttt{Location} object to a registered \texttt{LocationListener} by calling
its \texttt{onLocatoinChanged} method. To preserve the integrity of the
mocking context, we also block real sensor events from being published to
apps while replaying.

